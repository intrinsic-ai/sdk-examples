<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HMI</title>
<base href="{{.BaseURL}}" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@1.0.0/css/bulma.min.css" />

<section class="section">
  <div class="container">
    <h1 class="title">HMI</h1>
    <div class="box">
      Current status:
      <strong id="status" class="has-text-primary">Loading...</strong>
    </div>
    <div style="display: none" class="notification" id="result"></div>
    <div class="box">
      Select a behavior tree to execute:
      <select id="bt-list">
        <option value="">Select an option</option>
      </select>
    </div>
    <button disabled class="button is-success" id="start">Start Process</button>
    <button disabled class="button is-danger" id="stop">Stop</button>
    <div class="box" style="margin-top: 32px">
      <button class="button" id="states-list" style="margin-bottom: 16px">
        List/refresh service states
      </button>
      <div id="service-states" class="content"></div>
    </div>
    <div style="display: none" class="notification" id="state-result"></div>
  </div>
</section>

<script>
  let operationId = "";
  let behaviorTreeName = "";
  let showStatus = false;
  let states = [];

  const startEl = document.getElementById("start");
  const stopEl = document.getElementById("stop");
  const statusEl = document.getElementById("status");
  const resultEl = document.getElementById("result");
  const btListEl = document.getElementById("bt-list");
  const serviceStatesEl = document.getElementById("service-states");
  const listStatesEl = document.getElementById("states-list");
  refreshStatus();

  btListEl.addEventListener("mousedown", async () => {
    // Clear existing options.
    btListEl.innerHTML = '<option value="">Select an option</option>';

    // Add all currently saved behavior trees in solution.
    const options = await getBehaviorTrees();
    options.forEach((optionText) => {
      const option = document.createElement("option");
      option.value = optionText;
      option.text = optionText;
      btListEl.add(option);
    });
    behaviorTreeName = "";
  });

  btListEl.addEventListener("change", (event) => {
    behaviorTreeName = event.target.value;
    showStatus = false;
  });

  stopEl.addEventListener("click", stop);
  startEl.addEventListener("click", () => {
    start(behaviorTreeName);
  });

  listStatesEl.addEventListener("click", async () => {
    states = await listServiceStates();
  });

  async function refreshStatus() {
    if (!behaviorTreeName) {
      statusEl.textContent = "UNSPECIFIED";
      resultEl.style.display = "none";
    } else {
      try {
        const res = await fetch("api/executive/status");
        const s = await res.json();
        statusEl.textContent = showStatus ? s.status : "UNSPECIFIED";
        operationId = s.operationId;

        const runningStatuses = ["RUNNING", "SUSPENDING", "CANCELING"];
        if (operationId) {
          if (runningStatuses.includes(s.status)) {
            startEl.disabled = true;
            stopEl.disabled = false;
          } else {
            startEl.disabled = false;
            stopEl.disabled = true;
          }
        } else {
          startEl.disabled = false;
          stopEl.disabled = true;
        }

        if (s.done && showStatus) {
          if (s.error) {
            resultEl.classList.add("is-danger");
            resultEl.classList.remove("is-success");
            resultEl.textContent = s.error;
          } else {
            resultEl.classList.add("is-success");
            resultEl.classList.remove("is-danger");
            resultEl.textContent = "The process run succeeded";
          }
          resultEl.style.display = "block";
        } else {
          resultEl.style.display = "none";
        }
      } catch (e) {
        statusEl.textContent = s.error;
        operationId = "";
      }
    }

    if (states.length > 0) {
      let str = `
<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>State</th>
      <th>Enable</th>
      <th>Disable</th>
      <th>Restart</th>
    </tr>
  </thead>
  <tbody>
`;
      states.forEach(function (state) {
        let row = "<tr>";
        row += "<td>" + state.name + "</td>";
        row += "<td>" + state.state.stateCode + "</td>";
        row += `<td><button class="button" id="enable-${state.name}">Enable</button></td>`;
        row += `<td><button class="button" id="disable-${state.name}">Disable</button></td>`;
        row += `<td><button class="button" id="restart-${state.name}">Restart</button></td>`;
        row += "</tr>";
        str += row;
      });
      str += `
      </tbody>
      </table>
      `;
      serviceStatesEl.innerHTML = str;
      states.forEach(function (state) {
        addStateManagementHandlers(state.name);
      });
    }

    // Refresh the current status every second.
    setTimeout(refreshStatus, 1000);
  }

  function addStateManagementHandlers(name) {
    const notificationEl = document.getElementById("state-result");
    stateHandler(document.getElementById(`enable-${name}`), "enable", name, notificationEl);
    stateHandler(document.getElementById(`disable-${name}`), "disable", name, notificationEl);
    stateHandler(document.getElementById(`restart-${name}`), "restart", name, notificationEl);
  }

  function stateHandler(buttonEl, stateMethod, name, notificationEl) {
    buttonEl.addEventListener("click", async () => {
      try {
        notificationEl.style.display = "none";
        const req = new Request(`api/serviceStates/${name}/${stateMethod}`, {
          method: "POST",
        });
        const res = await fetch(req);
        const s = await res.json();
        if (s.error) {
          notificationEl.classList.add("is-danger");
          notificationEl.classList.remove("is-success");
          notificationEl.textContent = s.error;
        } else {
          notificationEl.classList.remove("is-danger");
          notificationEl.classList.add("is-success");
          notificationEl.textContent = `"${stateMethod}" successful.`;
        }
        notificationEl.style.display = "block";
      } catch (e) {
        notificationEl.classList.add("is-danger");
        notificationEl.classList.remove("is-success");
        notificationEl.textContent = `Failed to ${stateMethod} ${name}`;
        notificationEl.style.display = "block";
      }
    });
  }

  async function listServiceStates() {
    const res = await fetch("api/serviceStates");
    const s = await res.json();
    if (Array.isArray(s["states"])) {
      return s["states"];
    }
    return [];
  }

  async function getBehaviorTrees() {
    let s;
    try {
      const res = await fetch("api/solution_service/list");
      s = await res.json();
      if (Array.isArray(s["names"]) && s["names"].length > 0) {
        return s["names"];
      }
    } catch (e) {
      console.log(s.error);
    }
    return [];
  }

  async function stop() {
    if (!operationId) {
      return;
    }
    try {
      const req = new Request(`api/executive/${operationId}/stop`, {
        method: "POST",
      });
      await fetch(req);
    } catch (e) {
      console.log("Stopping failed:", e);
    }
  }

  async function start(processName) {
    if (!processName) {
      return;
    }
    try {
      const req = new Request("api/executive/start", {
        body: JSON.stringify({ processName }),
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
      });
      const res = await fetch(req);
      const s = await res.json();
      operationId = s.operationId;
    } catch (e) {
      console.log("Starting failed:", e);
    }
    showStatus = true;
  }
</script>
